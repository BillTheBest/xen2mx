* missing features (for PVFS2)
  + thread safety (including omx_wakeup)
  + omx_cancel
  + omx_disconnect
  + omx_set_request_timeout
  + omx_set_error_handler - if the default is return, I do not need this 

* finish and test the wrappers for MX API in myriexpress.h

* /etc/init.d/open-mx script with IFACES variable in /etc/open-mx.conf
* sethostname ioctl
* ioctls to change board indexes?

* move irecv and process_recv* to omx_recv.c

* check pingpong contents

* send a nack on bad session, except for connect (no session), truc or nack libs

* have a way to make install without the driver or only the driver (for local install as non-root)

* hide region id in lib_cookies since region might be used for something else?
* handle pull status/length
* keep a current (segment+offset+remaining) in user_region and recompute only when unordered
* export rdma_get and rdma window management functions
* rdma_put
* user region seqnum
* write parameter in ioctl to register a region, check it when reading/writing from/to the region
* what if too many small segments are in the same pull frame? (skb frags limit) copy in a linear skb or assume 
  the other side knows how to deal with smaller pull frames ?
* add an ioctl to repost a pull, and return the send_handle to the lib
* add an ioctl to drop a pull

* move recv lib in the kernel
  + limit unexpq size to avoid memory starvation
  + need to keep partner's recv_seqnum in the kernel
    - and synchronize with user-space which takes care of acking

* support eventq full by queueing things?
  - upto when? reserve before sending? should be guaranteed by the lib (polls before sending) => no need to queue?
  - use it for shared memory ?

* true sleeping in the kernel
  - pass the eventq index in the ioctl to avoid races
  - always wakeup on event?
  - wake up only one and have it wake up the right one ?
* progress thread sleeps on a special queue
  - some event wakeup both queues (force_wakeup)
  - other events wakeup the progress thread only no one on the regular queue

* debug
  - filter various debug message types
  - make driver dprintk runtime configurable

* pull on lo on same region deadlocks

* truc messages
* rendez-vous messages
* notify messages
* connect messages
* retransmission

* fix OMX_MTU_MIN with exact medium/pull max length
* add warning about mtu in nic/switches when truncated packet arrives, with printk_rate

* omx_endpoint_info

* mapper (open-mxd)
* /dev/open-mxd ?

* optimizations
  - likely/unlikely in the lib; for gcc only
  - single ioctl for multiple medium frags ?
  - no need to pad event to 64 ? no need to put the type at the end, but write it after the rest
  - optimize shared comms between boards from within the driver

* use IOAT
  + post a req
    cookie = dma_async_memcpy_pg_to_pg(chan, dst_page, dest_off, src_page, src_off, len)
  + send a batch of req
    dma_async_memcpy_issue_pending(chan)
  + poll completion of one cookie foo:
    dma_async_memcpy_complete(chan, cookie, NULL, NULL) == DMA_SUCCESS
  + poll completion up to last_cookie (see tcp_recvmsg() in net/ipv4/tcp.c)
    while dma_async_memcpy_complete(chan, last_cookie, &done, &used) == DMA_IN_PROGRESS
      while dma_async_is_complete(next_cookie, done, used) == DMA_SUCCESS
        free next_cookie's skb
    free all skb up to last_cookie
  + get/release a chan
    chan = get_softnet_dma()
    ...
    dma_chan_put(chan)
  + manage client/chan (see netdev_dma_event() net/core/dev.c)
    struct dma_client client.event_callback
    dma_async_client_register(client)
    dma_async_client_chan_request(client)

* use valgrind memory hooks
* add valgrind ioctl hooks

* ntoh[sl] fields

* add a VERSION file and a script to update MODULE_VERSION, COPYING and file headers ?

* non MXoE compatible extensions:
  + rdma in both direction with optional notification containing the target window id ?
  + no notify message, report event on rdma get completion ?
  + multiple segments in large messages, with random page offset (support in the driver, not used by the lib)
  + extend threshold for small/tiny ?
  + cleanup connect request/reply data
  + no bidirectionnal connect in the background
