* skb_clone and alloc_skb_fclone for pull and pull replies?
* netif_wake_queue(dev) after xmit?

* split out omx_common.h (and types.h?)

* factorize early and msg seqnum index computing (cache them?)

* shared comms between boards from within the driver
  + reject sends if no place in the target eventq so that we requeue them
    instead of dropping them and needing to ack them later ?

* wire compat
  + what's in src_generation ? unset/unchecked in OMX
  + no rdmawin_seqnum set/checked
  + lib ack contents

* optimize mediums
  + single ioctl, pipeline get_user_pages/dev_queue_xmit, put_pages in the last callback

* add retransmission
  + wakeup earlier if sleeping to send delayed acks
  + cancel a liback if sending a message before, or send liback after dequeuing request
  + split partner pendind queue in four quarter to prevent wrap around, and add throttling
  + throttle if too many partially received medium
  + add session to seqnums

* fix disconnect
  + cleanup pending sends, even if their state may be anything
  + cleanup pending connects too
  + call it when the connect session changed

* missing features (for PVFS2)
  + thread safety (including omx_wakeup)
  + omx_set_error_handler - if the default is return, I do not need this 

* sethostname ioctl
* ioctls to change board indexes?

* check pingpong contents

* vectorial support, through isendv/irecvv

* use rcu locking for various read/write locks?

* use large region id in the lib, only allocate uint8_t id for the wire when
  posting the rndv message or the pull request
* overlap registration with rndv and pull
  + mark the window as valid but not ready during registration
  + drop the pull request if it arrives
  + make the window status consistent during registration so that first pages
    may be used while the end is not registered yet
* hide region id in lib_cookies since region might be used for something else?
* keep a current (segment+offset+remaining) in user_region and recompute only when unordered
* export rdma_get and rdma window management functions
* rdma_put
* user region seqnum
* write parameter in ioctl to register a region, check it when reading/writing from/to the region
* what if too many small segments are in the same pull frame? (skb frags limit) copy in a linear skb or assume 
  the other side knows how to deal with smaller pull frames ?

* move recv lib in the kernel
  + limit unexpq size to avoid memory starvation
    - or allocate default unexp buffers upto 32kB
    - use a usual recv queue for unexp?
  + need to keep partner's recv_seqnum in the kernel
    - and synchronize with user-space which takes care of acking
    - share mapping of peer-index based array of recv seqnums between kernel and user-space?

* sleep on various event type to not wake up everybody
* thread safety
* omx_wakeup
* progress thread sleeps on a special queue
  - some event wakeup both queues (force_wakeup)
  - other events wakeup the progress thread only if no one on the regular queue

* add warning about mtu in nic/switches when truncated packet arrives, with printk_rate

* mapper (open-mxd)
* /dev/open-mxd ?

* use IOAT
  + post a req
    cookie = dma_async_memcpy_pg_to_pg(chan, dst_page, dest_off, src_page, src_off, len)
  + send a batch of req
    dma_async_memcpy_issue_pending(chan)
  + poll completion of one cookie foo:
    dma_async_memcpy_complete(chan, cookie, NULL, NULL) == DMA_SUCCESS
  + poll completion up to last_cookie (see tcp_recvmsg() in net/ipv4/tcp.c)
    while dma_async_memcpy_complete(chan, last_cookie, &done, &used) == DMA_IN_PROGRESS
      while dma_async_is_complete(next_cookie, done, used) == DMA_SUCCESS
        free next_cookie's skb
    free all skb up to last_cookie
  + get/release a chan
    chan = get_softnet_dma()
    ...
    dma_chan_put(chan)
  + manage client/chan (see netdev_dma_event() net/core/dev.c)
    struct dma_client client.event_callback
    dma_async_client_register(client)
    dma_async_client_chan_request(client)
  + for recv large, wait for the last completion before reporting pull 
    done completion. or send copy the last frag manually without IOAT
  + for medium, how to report an event and wakeup userspace efficiently
    if we are not notified of the IOAT completion end?
  + might be easier medium with kernel matching?

* non MXoE compatible extensions:
  + rdma in both direction with optional notification containing the target window id ?
  + no notify message, report event on rdma get completion ?
  + multiple segments in large messages, with random page offset (support in the driver, not used by the lib)
  + extend threshold for small/tiny ?
  + cleanup connect request/reply data
  + no bidirectionnal connect in the background
  + if pulling outside of the remote window, send a nack?
