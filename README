Contents:
   I. Quick Start
  II. Building and Installing
    a. Basic Install
    b. Kernel Module
    c. Caveats
 III. Kernel Module and /dev/open-mx Device Node
  IV. Attaching interfaces
   V. Peer Table File
  VI. Performance tuning
    a. Wire-compatibility
    b. Registration Cache
    c. Interrupt Coalescing
    d. Shared/Self communications
    e. Avoiding Linearizing on the receive side with old kernels
    f. Quick benchmarking how-to
 VII. Native MX Compatibility
    a. Wire-compatibility
    b. API-compatibility
VIII. Advanced configuration
    a. Build-time configuration options
    b. Configurations tricks for middleware
    c. Runtime configuration options
    d. Module parameters
  IX. Debugging

See REPORTING-BUGS for problems.


++================++
|| I. Quick Start ||
++================++

Assuming you want to connect 2 nodes using their 'eth2' interface:

a. Build and install Open-MX in /opt/open-mx
   $ ./configure
   $ make
   $ make install

   Note that if building from SVN, you will need to generate the
   configure script and common/omx_config.h.in header first.
   autoconf and autoheader are required to do so:
   $ autoconf
   $ autoheader

b. Load the open-mx kernel module and tell it which interface to use
     $ /path/to/open-mx/sbin/omx_init start ifnames=eth2
   See sections II (Building and Installing)
   and III (Kernel Module and /dev/open-mx Device Node) for details.

c. Look for eth2 MAC addresses in /sbin/ifconfig -a on each node.
   and insert them in a file such as this one:
     $ cat /path/to/the/peers/file
     01:02:03:04:05:06 node1:0
     a0:b0:c0:d0:e0:f0 node2:0

d. Make Open-MX use this file:
     $ /path/to/open-mx/bin/omx_init_peers /path/to/the/peers/file
   See section IV (Attaching interfaces) for details.

e. Make sure both interfaces are up with a large MTU
     $ ifconfig eth2 up mtu 9000

f. Run omx_info to see which interfaces are attached and which
   peers are accessible:
     $ omx_info
     node1:0 (board #0 name eth2 addr 01:02:03:04:05:06)
     ==============================================
     1) 01:02:03:04:05:06 node1:0
     2) a0:b0:c0:d0:e0:f0 node2:0

g. Use omx_pingpong to test actual communications, on the first node:
     node1 $ omx_pingpong
     Successfully attached endpoint #0 on board #0 (hostname 'node1:0', name 'eth2', addr 01:02:03:04:05:06)
     Starting receiver...
   then on the second node:
     node2 $ omx_pingpong -d node1:0
     Successfully attached endpoint #0 on board #0 (hostname 'node2:0', name 'eth2', addr a0:b0:c0:d0:e0:f0)
     Starting sender to node1:0...
   You should get performance numbers such as
     length         0:       7.970 us   0.00 MB/s        0.00 MiB/s
     length         1:       7.950 us   0.00 MB/s        0.00 MiB/s
     [...]
     length   4194304:       8388.608 us   500.00 MB/s       476.83 MiB/s


++=============================++
|| II. Building and Installing ||
++=============================++

+---------------------
| II.a. Basic Install

    $ ./configure
    $ make
    $ make install

To display full build command line instead of the default short messages,
V=1 should be passed to make.

By default, Open-MX will be installed in /opt/open-mx. Use --prefix on
the configure line to change this (or set prefix on the 'make install'
command line).

To simplify Open-MX startup, you might want to install the initialization
script on each node:
    $ sbin/omx_local_install
Then Open-MX may be started with:
    $ /etc/init.d/open-mx start
You might want to configure your system to auto-load this script at
startup.

The /etc/open-mx/open-mx.conf may be modified to configure which
interfaces should be attached at startup.
The /etc/open-mx/peers file may be created and filled with a static
peers table (see V).

+---------------------
| II.b. Kernel Module

Open-MX is composed of a user-space library with passes communication
commands to a kernel module. This module 'open-mx' will be installed
in lib/modules/<kernel>/ with the Open-MX installation, i.e.
/opt/open-mx/lib/modules/<kernel>/ by default.

During configure, Open-MX checks the running kernel with 'uname -r' and
builds the open-mx module against it, using its headers and build tree
in /lib/modules/`uname -r`/{source,build}.

To build for another kernel, use
$ ./configure --with-linux=/path/to/kernel/headers/
To build using another kernel build tree, use
$ ./configure --with-linux=/path/to/kernel/headers/ --with-linux-build=/path/to/kernel/build/tree/

The kernel module must be compiled with the same compiler than the
kernel has been. To change the compiler for the kernel module, pass
KCC=<othercompiler> on the configure or make command line.

+---------------
| II.c. Caveats

II.c.1. Installing as root over NFS

Most NFS configurations do not allow root on the client to operate
as root on the server's files. When running 'make install' as root,
you might experience problems because some Makefiles (especially
the kernel driver's one) might modify some files before actually
installing anything.

To work around this, assuming everything has been built as non-root
before, you may use (as root)
$ make installonly
so that it really only installs things without checking whether the
build is up-to-date.


++=================================================++
|| III. Kernel Module and /dev/open-mx Device Node ||
++=================================================++

The 'open-mx' kernel module should be loaded prior to any user-space
usage of Open-MX. If not loaded, a "No device" error will be returned.
The omx_init script takes care of loading the module
$ /path/to/open-mx/sbin/omx_init start ifnames=eth2

This module works at least on Linux kernels 2.6.17 to 2.6.24 on i386
and x86_64 architectures. It also builds fine with kernels up to 2.6.15
but has not been tested intensively on these.

Once the module is loaded, udev creates a /dev/open-mx file which is
used by user-space libraries and programs. Additionally, the Open-MX
init script will create the device node in case udev was not running.
The --with-device configure option may be used to change the name of
this device file, its group or mode. Write access to this file is
required when using Open-MX.

Kernels older than 2.6.15 are unlikely to be supported due to various
important functions being unavailable (especially vm_insert_page).


++==========================++
|| IV. Attaching interfaces ||
++==========================++

By default, all existing network interfaces in the system will be
attached to Open-MX (except those above 8 by default), except the
ones that are not Ethernet, are not up, or have a small MTU.

To change the order or select which interfaces to attach, you may
use the ifnames module parameter when loading:
$ modprobe open-mx ifnames="eth3,eth2"

The current list of attached interfaces may be observed by reading
the /sys/module/open_mx/parameters/ifnames special file.
Writing 'foo' or '+foo' in the file will attach interface 'foo'.
Writing '-bar' will detach interface 'bar', except if some endpoints
are still using it. To force the removal of an interface even if some
endpoints are still using it, '--bar' should be written in the special
file. Multiple commands may be sent at once by separating them with
commas.

The list of currently open endpoints may be seen with:
$ omx_endpoint_info
The interfaces may also be observed with the omx_info user-space
tool.

Note that these interfaces must be 'up' in order to work.
$ ifconfig eth2 up
However, having an IP address is not required.

Also, the MTU should be large enough for Open-MX packets to transit.
9000 will always be enough. Look in dmesg for the actual minimal MTU
size, which may depend on the configuration.
$ ifconfig eth2 mtu 9000


++====================++
|| V. Peer Table File ||
++====================++

A file listing peers must be provided to store the list of hostnames
and mac addresses in the driver. The omx_init_peers tool may be used to
setup this list.

The omx_init startup script takes care of running omx_init_peers
automatically using /etc/open-mx/peers when it exists.
The --with-peers-file=<path> configure option may be used to change
the location of this default peers file to load in omx_init.

The contents of the file is one line per peer, each containing
2 fields (seperated by spaces or tabs):
* a mac address (6 colon-separated numbers)
* a board hostname (<hostname>:<ifacenumber>)


++========================++
|| VI. Performance tuning ||
++========================++

+-------------------------------
| VI.a. Wire-compatibility

Open-MX enables 2 types of wire-compatibility by default, native-MX
compatibility and endian-independent compatibility. Disabling them
when they are not needed may improve the performance.

If native MX compatibility is not required on the wire you might want
to pass --disable-mx-wire to the configure command line so that larger
packets are used for large messages. Note that the required MTU will
jump from roughly 4kB to 8.
See section VII (Native MX Compatibility) for details about wire
compatibility.

If the machines on the network all use the same endian-ness, you might
want to pass --disable-endian to the configure command line so that
Open-MX does not swap header bits into/from network order. It may reduce
the latency very slightly.

+--------------------------
| VI.b. Registration Cache

Achieving optimal performance requires to avoid memory copies as much
as possible. This is done using memory registration, which pins buffers
in physical memory. Since this operation is expensive, it is interesting
to do only once per buffer when the buffer is used multiple times.
To do so, you should set the OMX_RCACHE environment variable to 1.
$ export OMX_RCACHE=1

However, this configuration may be dangerous if the application frees
the buffer in the meantime. Since Open-MX has no way to detect this
for now, this registration cache should be used with caution.

+----------------------------
| VI.c. Interrupt Coalescing

Most Ethernet drivers use interrupt coalescing to avoid interrupting the
host once per incoming packet. While this is good for the throughput, it
increase the latency a lot, up to dozens of milliseconds.

To get the best latency for Open-MX, interrupt coalescing should be reduced.
The easiest way to do so is to disable it completely.
$ ethtool -C eth2 rx-usecs 0

However, it is often better to set it close to the latency so that the
observed latency is as optimal while there is still a bit of coalescing
for consecutive packets. So, assuming that you observe a N usecs latency
with Open-MX when interrupt coalescing is disabled, a nice configuration
would to set coalescing to N or N-1 usecs:
$ ethtool -C eth2 rx-usecs <N-1>

+----------------------------------
| VI.d. Shared/Self communications

Open-MX may use a software loopback to send messages from one endpoint to
itself (self communications) or to another endpoint of any interface of the
same host (shared communications). This loopback is faster than going on the
network up to a switch and then coming back. And it is guaranteed to work
(while some switches don't send packets back to their sender).

If these shared/self communication are useless, the library overhead may be
slightly reduced by disabling them either at build-time with --disable-self
or --disable-shared, or at runtime by setting OMX_DISABLE_SELF=1 or
OMX_DISABLE_SHARED=1 in the environment.

This is especially the case if there is a single process on each node and
it doesn't talk to itself, or if multiple processes of the same don't talk
to each other.

+-----------------------------------------------------------------
| VI.e. Avoiding Linearizing on the receive side with old kernels
|       and frag-based drivers

Some old kernels (<2.6.18) have problems with some drivers that receive
data in frags (non-linear skbuff). As a workaround, they will linearize
these skbuffs unless their target protocol stack explicitly supports
non-linear skbuff. This basically adds a memory copy for all packets
except IPv4 and IPv6, which would decrease Open-MX performance.

To avoid this, if IPv6 is not in use on the network, you might want to
tell Open-MX to use the IPv6 Ethernet type. This way, its skbuffs will
not be linearized uselessly. To enable this workardound, you should pass
--with-ethertype=0x86DD to the configure command line.

** Note that this solution is only required under very special
   circumstances and should be avoided in most of the cases. **

+---------------------------------
| VI.f. Quick benchmarking how-to

To get best performance for benchmarking purposes between homogeneous hosts,
you might want to:
* Build Open-MX with --disable-endian, --disable-mx-wire, probably --disable-self
  as well, and even --disable-shared if there is a single process per host.
* Make sure no cores are sleeping since they would be slow to process incoming
  packets. Booting Linux with idle=poll is an easy way to prevent this sleeping.
  Another one is to have a task using 100% on each core as any real-life
  application would do.
* To reduce cache-effects without sharing a single core power between bottom
  halves and the main process, bind the process on one core (close to the
  network interface, with numactl or taskset), and bind the interrupts of the
  Ethernet interface on a very close core (by writing the corresponding mask
  into /proc/irq/<n>/smp_affinity).


++==============================++
|| VII. Native MX Compatibility ||
++==============================++

Open-MX provides API- and wire-compatibility with the native MX stack.

+---------------------------
| VII.a. Wire-compatibility

If you need some Open-MX hosts to talk to some MX hosts, you should
keep the wire-compatibility enabled (it is enabled by default).
If you only have Open-MX hosts talking on the network, you can disable
it to improve performance (see VI.a).

+--------------------------
| VII.b. API-compatibility

While the Open-MX API is slightly different from the MX one, it provides
a compatibility layer which enables building of any MX application on
top of Open-MX. This layer is enabled by default and should not cause
any problem, it just installs more files. To disable it, you should pass
--disable-mx to the configure command line.

Binary compatibility is not supported yet, which means you will always
have to rebuild against Open-MX headers.


++==============================++
|| VIII. Advances configuration ||
++==============================++

The Open-MX behavior may be either configured at build-time with configure
options, or at runtime with environment variables.

+-----------------------------------------------------
| VIII.a. Summary of build-time configuration options

The following options may be passed to the configure command line before
building:

--enable-debug
	Only build a debugging library.
--disable-debug
	Only build a non-debugging library.
  Both a debug and a non-debug are built by default, and the non-debug one
  is used to link all tests/tools programs.

--disable-endian
	Disable variable endian architectures support on the wire.
  Endian-ness independent wire protocol is enabled by default.

--disable-self
	Disable software loopback between an endpoint and itself.
  Self software loopback is enabled by default.

--disable-shared
	Disable software loopback between endpoints of the same node.
  Shared software loopback is enabled by default.

--enable-valgrind
	Enable Valgrind hooks in the non-debugging library.
--disable-valgrind
	Disable Valgrind hooks in the debugging library.
  By default, Valgrind is only enabled in the debugging library.

--disable-mx
	Do not build/export any MX compatibility wrapper.
--enable-unsupported-mx
	Build the unsupported routines in the MX compatibility wrappers.
  Only the supported MX routines have their compatiblity wrappers
  enabled by default.

--disable-mx-wire
	Optimize the wire-protocol by not being compatible with MXoE.
  The wire protocol is compatible with MXoE by default.

+--------------------------------------------------
| VIII.b. Summary of runtime configuration options

The following environment variables may be used to change the library
behavior at runtime:

OMX_DISABLE_SELF=1
	Disable software loopback between an endpoint and itself.
  Self software loopback is enabled by default.

OMX_DISABLE_SHARED=1
	Disable software loopback between endpoints of the same node.
  Shared software loopback is enabled by default.

OMX_RCACHE=1
	Enable registration cache.
  The registration is disabled by default.

OMX_RESENDS_MAX=1000
	Try to resend each send request 1000 times before timeout-ing.
  By default, each request is resent up to 1000 times before timeout-ing.

OMX_NOTACKED_MAX=4
	Allow a maximum of 4 messages not acked per partner. When passing
  this threshold, an explicit ack is sent immediatly if needed.

OMX_VERBOSE=1
	Display verbose messages.
  No verbose messages are displayed by default, except in the debugging
  library.

OMX_VERBDEBUG=<mask>
	Display verbose debugging messages in the debugging library.
  No verbose debugging messages are displayed by default.

OMX_WAITSPIN=1
	Busy loop instead of sleeping in blocking functions.
  Blocking functions sleep by default.

OMX_WAITINTR=1
	Let sleeping functions be interruptible by signals.
  Blocking functions go back to sleep on signal by default.

OMX_ZOMBIE_SEND=512
	Tolerate the completion of 512 sends before their actual ack.
  At most 512 zombies are completed before being acked by default.

+---------------------------
| VIII.c. Module parameters

The following module parameters may be passed to the driver module when loading,
either as a parameter to the modprobe command, or through the OMX_MODULE_PARAMS
variable for the omx_init or /etc/init.d/open-mx startup script:

ifnames="eth2 eth3"
	Attach interfaces eth2 and eth3 at startup instead of all interfaces.
	See section IV (Attaching interfaces) for details.
ifaces=32
	Allow a maximum of 32 interfaces to be attached at the same time.
	Default is 32.
endpoints=8
	Allow a maximum of 8 endpoints to be open by interfaces.
	Default is 8.
peers=1024
	Allow a maximum of 1024 peers to be connected on the network.
	Default is 1024.
dmaengine=1
	Enable DMA engine to offload memory copies.
	Default is 0 (disabled).
dmamin=1024
	Use DMA engine copy offload only when length is above the threshold.
	Default is 1024 bytes.
skbfrags=16
	Allow a maximum of 16 frags to be attached to socket buffer on the
	send side. If the underlying driver does not support frags, 0 should
	be used.
	The default and maximal value is MAX_SKB_FRAGS (16 on common archs).
skbcopy=0
	Copy buffers upto 0 bytes into a linear skb instead of attaching
	pages. If the underlying driver is slow sending frags, increasing
	this parameter to copy small frags into linear skb may be faster
	than using frags as usual.
copybench=1
	Enable a memory copy benchmark at startup.
	Default is disabled (0).

+----------------------------------------------
| VIII.d. Configuration tricks for middlewares

If you plan to use Open-MX within a middleware such as a MPI layer, you
should read the following configuration advices:
* MX API compatibility:
  Passing --disable-mx to the Open-MX configure line is only possible if all
  middlewares involved use the native Open-MX API. In most cases, keeping the
  MX API compatibility enabled should cause no harm and is thus recommended.
  Once Open-MX is installed, passing its installation path to the middleware
  configuration system as the MX installation path should do the trick.
* Thread-safety:
  A thread-safe middleware should generally rely on a thread safe Open-MX.
  Building Open-MX without --enable-threads may only work if caller uses
  neither any blocking Open-MX functions nor the unexpected handler, and
  obviously serializes Open-MX calls.
* Self and Shared communications:
  Most MPI layers implement there own shared memory protocol as well as
  communication to self. It may then be a good idea to build Open-MX with
  --disable-shared and --disable-self.


++===============++
|| IX. Debugging ||
++===============++

Open-MX provides several debugging features such as verbose messages,
additional checks, non-optimized building, valgrind hooks, ... For
performance reasons, they are not enabled by default.

By default, Open-MX will build a non-debug library and an optional debug
library. The former is installed in $prefix/lib while the latter goes in
$prefix/lib/debug. The driver is built without debug by default.

Passing --disable-debug to the configure command line will only disable
the build of the debug library. Passing --enable-debug will make only
the debug library be built and installed in $prefix/lib as usual, and the
driver will be debug enabled.

The build flags may be configured by passing CFLAGS on the configure
command line. Additional flags may be passed for the debugging library
build with DBGCFLAGS.
