Contents:
  I. Quick Start
 II. Building and Installing
   a. Basic Install
   b. Kernel Module
   c. Caveats
III. Kernel Module and /dev/open-mx Device Node
 IV. Attaching interfaces
  V. Peer Table File
 VI. Performance tuning
   a. Wire-compatibility
   b. Registration Cache
   c. Interrupt Coalescing
   d. Avoiding Linearizing on the receive side with old kernels
VII. Native MX Compatibility
   a. Wire-compatibility
   b. API-compatibility


See REPORTING-BUGS for problems.

+----------------+
| I. Quick Start |
+----------------+

Assuming you want to connect 2 nodes using their 'eth2' interface:

a. Build and install Open-MX in /opt/open-mx
   $ ./configure
   $ make
   $ make install

   Note that if building from SVN, you might need to generate the
   configure script first. autoconf and autoheader are required,
   autoreconf will take care of running them:
   $ autoreconf -ifv

b. Load the open-mx kernel module and tell it which interface to use
     $ /path/to/open-mx/sbin/omx_init start ifnames=eth2
   See section II and III for details.

c. Look for eth2 MAC addresses in /sbin/ifconfig -a on each node.
   and insert them in a file such as this one:
     $ cat /path/to/the/peers/file
     01:02:03:04:05:06 node1:0
     a0:b0:c0:d0:e0:f0 node2:0

d. Make Open-MX use this file:
     $ /path/to/open-mx/bin/omx_init_peers /path/to/the/peers/file
   See Section IV for details.

e. Make sure both interfaces are up with a large MTU
     $ ifconfig eth2 up mtu 9000

f. Run omx_info to see which interfaces are attached and which
   peers are accessible:
     $ omx_info
     node1:0 (board #0 name eth2 addr 01:02:03:04:05:06)
     ==============================================
     1) 01:02:03:04:05:06 node1:0
     2) a0:b0:c0:d0:e0:f0 node2:0

g. Use omx_pingpong to test actual communications, on the first node:
     node1 $ omx_pingpong
     Successfully attached endpoint #0 on board #0 (hostname 'node1:0', name 'eth2', addr 01:02:03:04:05:06)
     Starting receiver...
   then on the second node:
     node2 $ omx_pingpong -d node1:0
     Successfully attached endpoint #0 on board #0 (hostname 'node2:0', name 'eth2', addr a0:b0:c0:d0:e0:f0)
     Starting sender to node1:0...
   You should get performance numbers such as
     length         0:       7.970 us   0.00 MB/s        0.00 MiB/s
     length         1:       7.950 us   0.00 MB/s        0.00 MiB/s
     [...]
     length   4194304:       8388.608 us   500.00 MB/s       476.83 MiB/s


+-----------------------------+
| II. Building and Installing |
+-----------------------------+

+---------------------
| II.a. Basic Install

    $ ./configure
    $ make
    $ make install

By default, Open-MX will be installed in /opt/open-mx. Use --prefix on
the configure line to change this (or set prefix on the 'make install'
command line).

To simplify Open-MX startup, you might want to install the initialization
script on each node:
    $ sbin/omx_local_install
Then Open-MX may be started with:
    $ /etc/init.d/open-mx start
You might want to configure your system to auto-load this script at
startup.

The /etc/open-mx/open-mx.conf may be modified to configure which
interfaces should be attached at startup.
The /etc/open-mx/peers file may be created and filled with a static
peers table (see V).

+---------------------
| II.b. Kernel Module

Open-MX is composed of a user-space library with passes communication
commands to a kernel module. This module 'open-mx' will be installed
in lib/modules/<kernel>/ with the Open-MX installation, i.e.
/opt/open-mx/lib/modules/<kernel>/ by default.

During configure, Open-MX checks the running kernel with 'uname -r' and
builds the open-mx module against it, using its headers and build tree
in /lib/modules/`uname -r`/{source,build}.

To build for another kernel, use
$ ./configure --with-linux=/path/to/kernel/headers/
To build using another kernel build tree, use
$ ./configure --with-linux=/path/to/kernel/headers/ --with-linux-build=/path/to/kernel/build/tree/

The kernel module must be compiled with the same compiler than the
kernel has been. To change the compiler for the kernel module, pass
KCC=<othercompiler> on the configure or make command line.

+---------------
| II.c. Caveats

II.c.1. Installing as root over NFS

Most NFS configurations do not allow root on the client to operate
as root on the server's files. When running 'make install' as root,
you might experience problems because some Makefiles (especially
the kernel driver's one) might modify some files before actually
installing anything.

To work around this, assuming everything has been built as non-root
before, you may use (as root)
$ make installonly
so that it really only installs things without checking whether the
build is up-to-date.


+-------------------------------------------------+
| III. Kernel Module and /dev/open-mx Device Node |
+-------------------------------------------------+

The 'open-mx' kernel module should be loaded prior to any user-space
usage of Open-MX. If not loaded, a "No device" error will be returned.
The omx_init script takes care of loading the module
$ /path/to/open-mx/sbin/omx_init start ifnames=eth2

This module works at least on Linux kernels 2.6.17 to 2.6.24 on i386
and x86_64 architectures. It also builds fine with kernels up to 2.6.15
but has not been tested intensively on these.

Once the module is loaded, udev creates a /dev/open-mx file which is
used by user-space libraries and programs. Additionally, the Open-MX
init script will create the device node in case udev was not running.
The --with-device configure option may be used to change the name of
this device file, its group or mode. Write access to this file is
required when using Open-MX.

Kernels older than 2.6.15 are unlikely to be supported due to various
important functions being unavailable (especially vm_insert_page).

+--------------------------+
| IV. Attaching interfaces |
+--------------------------+

By default, all existing network interfaces in the system will be
attached to Open-MX (except those above 8 by default). To change
the order or select which interfaces to attach, you may use the
ifnames module parameter when loading:
$ modprobe open-mx ifnames="eth3 eth2"

The current list of attached interfaces may be observed by reading
the /sys/class/misc/open-mx/ifaces special file.
Writing 'foo' or '+foo' in the file will attach interface 'foo'.
Writing '-bar' will detach interface 'bar', except if some endpoints
are still using it. To force the removal of an interface even if some
endpoints are still using it, '--bar' should be written in the special
file.

The list of currently open endpoints may be seen with:
$ omx_endpoint_info
The interfaces may also be observed with the omx_info user-space
tool.

Note that these interfaces must be 'up' in order to work.
$ ifconfig eth2 up
However, having an IP address is not required.

Also, the MTU should be large enough for Open-MX packets to transit.
9000 will always be enough. Look in dmesg for the actual minimal MTU
size, which may depend on the configuration.
$ ifconfig eth2 mtu 9000


+--------------------+
| V. Peer Table File |
+--------------------+

A file listing peers must be provided to store the list of hostnames
and mac addresses in the driver. The omx_init_peers tool may be used to
setup this list.

The omx_init startup script takes care of running omx_init_peers
automatically using /etc/open-mx/peers when it exists.
The --with-peers-file=<path> configure option may be used to change
the location of this default peers file to load in omx_init.

The contents of the file is one line per peer, each containing
2 fields (seperated by spaces or tabs):
* a mac address (6 colon-separated numbers)
* a board hostname (<hostname>:<ifacenumber>)


+------------------------+
| VI. Performance tuning |
+------------------------+

+-------------------------------
| VI.a. Wire-compatibility

Open-MX enables 2 types of wire-compatibility by default, native-MX
compatibility and endian-independent compatibility. Disabling them
when they are not needed may improve the performance.

If native MX compatibility is not required on the wire (see section VII),
you might want to pass --disable-mx-wire to the configure command line so
that larger packets are used for large messages.
Note that the required MTU will jump from roughly 4kB to 8.

If the machines on the network all use the same endian-ness, you might
want to pass --disable-endian to the configure command line so that
Open-MX does not swap header bits into/from network order. It may reduce
the latency very slightly.

+--------------------------
| VI.b. Registration Cache

Achieving optimal performance requires to avoid memory copies as much
as possible. This is done using memory registration, which pins buffers
in physical memory. Since this operation is expensive, it is interesting
to do only once per buffer when the buffer is used multiple times.
To do so, you should set the OMX_RCACHE environment variable to 1.
$ export OMX_RCACHE=1

However, this configuration may be dangerous if the application frees
the buffer in the meantime. Since Open-MX has no way to detect this
for now, this registration cache should be used with caution.

+----------------------------
| VI.c. Interrupt Coalescing

Most Ethernet drivers use interrupt coalescing to avoid interrupting the
host once per incoming packet. While this is good for the throughput, it
increase the latency a lot, up to dozens of milliseconds.

To get the best latency for Open-MX, interrupt coalescing should be reduced.
The easiest way to do so is to disable it completely.
$ ethtool -C eth2 rx-usecs 0

However, it is often better to set it close to the latency so that the
observed latency is as optimal while there is still a bit of coalescing
for consecutive packets. So, assuming that you observe a N usecs latency
with Open-MX when interrupt coalescing is disabled, a nice configuration
would to set coalescing to N or N-1 usecs:
$ ethtool -C eth2 rx-usecs <N-1>

+-----------------------------------------------------------------
| VI.d. Avoiding Linearizing on the receive side with old kernels

Some old kernels (<2.6.18) have problems with drivers that may receive
data in frags (non-linear skbuff). As a workaround, they will linearize
these skbuffs unless their target protocol stack explicitly supports
non-linear skbuff. This basically adds a memory copy for all packets
except IPv4 and IPv6, which would decrease Open-MX performance.

To avoid this, if IPv6 is not in use on the network, you might want to
tell Open-MX to use the IPv6 Ethernet type. this way, its skbuffs will
not by linearized uselessly. Note that this solution is only required
under very special circumstances.

To use IPv6 in order to avoid useless linearizing of received skbuffs,
you should pass --with-ethertype=0x86DD to the configure command line.


+------------------------------+
| VII. Native MX Compatibility |
+------------------------------+

Open-MX provides API- and wire-compatibility with the native MX stack.

+---------------------------
| VII.a. Wire-compatibility

If you need some Open-MX hosts to talk to some MX hosts, you should
keep the wire-compatibility enabled (it is enabled by default).
If you only have Open-MX hosts talking on the network, you can disable
it to improve performance (see VI.a).

+--------------------------
| VII.b. API-compatibility

While the Open-MX API is slightly different from the MX one, it provides
a compatibility layer which enables building of any MX application on
top of Open-MX. This layer is enabled by default and should not cause
any problem, it just installs more files. To disable it, you should pass
--disable-mx to the configure command line.

Binary compatibility is not supported yet, which means you will always
have to rebuild against Open-MX headers.
